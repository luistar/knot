var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/docs/node-reference/trajectory-partitioner/trajectory-partitioner/",title:"Trajectory Partitioner",description:"The Trajectory Partitioner node takes as input a collection of Floating Car Data (FCD) from possibly many vehicles and partitions it into subsets, each representing a distinct trajectory.",content:'\u003c!-- \u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis documentation page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e --\u003e\r\n\u003ch2 id="node-description"\u003eNode description\u003c/h2\u003e\n\u003cp\u003eThis node takes as input a collection of Floating Car Data (FCD) from possibly many vehicles and partitions it into subsets, each representing a distinct trajectory.\u003c/p\u003e\n\u003ch2 id="configuration-options"\u003eConfiguration options\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePartitioning strategy\u003c/strong\u003e This option allows users to select a trajectory partitioning strategy.\nCurrently, only one option (default) is supported. The default strategy splits the stream of GPS positions from a given vehicles into\ndifferent trajectories everytime the vehicle remains stationary for more time than a customizable threshold.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCoordinate Input Format\u003c/strong\u003e Either {lon, lat} or {lat, lon}, accordingly to the input format.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAllow trajectories spanning over multiple days\u003c/strong\u003e If selected, a trajectory can span over multiple days. Otherwise, two subsequent\nrecordings in two different days will always be assigned to different routes.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMinimum amount of minutes on hold to split trajectories\u003c/strong\u003e A value in minutes that controls wether two subsequent\nrecording belong to the same route. If a vehicle remained stationary for more time\nthan this threshold value, then the next active position will be considered the start of a new trajectory and\nthe previous trajectory is closed.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDiscard trajectories having less points than\u003c/strong\u003e Routes\ncontaining less points than this value will be discarded.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="inputs-and-outputs"\u003eInputs and outputs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eInput port\u003c/strong\u003e \u003cem\u003eInput Floating Car Data\u003c/em\u003e - A table containing the following\ncolumns:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVehicle ID, identifying the position owner.\u003c/li\u003e\u003c/li\u003e\n\u003cli\u003eTimestamp, a String containining information about the time of the recording.\u003c/li\u003e\u003c/li\u003e\n\u003cli\u003eGeometry, a GPS position in WKT format (e.g.: \u0026ldquo;POINT(coordinate coordinate)\u0026quot;)\u003c/li\u003e\nThe input table must be sorted by vehicle ID.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eTrajectories\u003c/em\u003e - A data table containing an entry for each identified\nTrajectory. Each trajectory is characterized by a Trajectory ID, an initial timestamp, and a geometry objects\nencoded as a Linestring in WKT format.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eInput data augmented with a Trajectory ID\u003c/em\u003e - The input data augmented with an additional Trajectory ID column, associating each Floating Car Data with the trajectory it belongs to.\u003c/outPort\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ## Input and output ports\r\n\r\n\u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eNotice that, for the node to behave correctly, the input table should be sorted by Vehicle ID. We recommend you use the \u003ca href="https://hub.knime.com/knime/extensions/org.knime.features.base/latest/org.knime.base.node.preproc.sorter.SorterNodeFactory"\u003eSorter\u003c/a\u003e KNIME node to efficiently sort your dataset, if needed.\u003c/div\u003e\r\n\u003c/div\u003e\r\n\r\n## Dialog parameters\r\n\r\n## Node implementation\r\n\r\n### Routing Strategies\r\n --\u003e\r\n'},{id:1,href:"/docs/usage-example/rome-example/",title:"Rome Taxi Dataset Coverage Analysis",description:"Use KNOT to perform a spatio-temporal coverage analysis on a real-world Taxi mobility dataset recorded in the City of Rome, Italy.",content:'\u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis tutorial page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e\n\u003ch2 id="rome-taxi-dataset-coverage-analysis"\u003eRome Taxi Dataset Coverage Analysis\u003c/h2\u003e\n\u003cp\u003eCheck out \u003ca href="https://zenodo.org/record/4680770"\u003ethis link\u003c/a\u003e for instructions, data,\nand supplemental material to reproduce this use case.\u003c/p\u003e\n\u003c!-- ## Getting the data --\u003e\r\n\u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eðŸ’¡\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003ePerforming a coverage analysis on the whole Rome Taxi Dataset could take up to a few hours, depending on your hardware configuration.\u003c/div\u003e\r\n\u003c/div\u003e\n\u003c!-- ## Setting up a KNIME workflow --\u003e\r\n'},{id:2,href:"/docs/node-reference/trajectory-manipulator/trajectory-manipulator/",title:"Trajectory Calculator",description:"Computes routes from possibly sparse FCD according to different strategies.",content:'\u003c!-- \u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis documentation page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e --\u003e\r\n\u003ch2 id="node-description"\u003eNode description\u003c/h2\u003e\n\u003cp\u003eThis Node takes as input a table with the same structure as the \u0026ldquo;Input data augmented with a Trajectory ID\u0026rdquo; output of the \u0026ldquo;Trajectory Partitioner\u0026rdquo; node and\ncomputes vehicular trajectories according to a customizable strategy, producing in output a new set of\ntrajectories encoded as WKT Linestrings.\nAs for the routing strategies, currently only \u0026ldquo;shortest path\u0026rdquo; is supported.\nThis strategy considers only the first and the last points in the original trajectory,\nand computes the shortest path between them. If the original trajectory contains more than two positions,\nthe additional positions will be ignored.\u003c/p\u003e\n\u003ch2 id="configuration-options"\u003eConfiguration options\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCoordinate Input Format\u003c/strong\u003e  Either {lon, lat} or {lat, lon}, accordingly to the input format.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRouting Service\u003c/strong\u003e The routing service to be used.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRouting Server endpoint\u003c/strong\u003e  Specifies the endpoint for the routing service.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRouting Strategy\u003c/strong\u003e  Allows the user to select a routing strategy.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMinum Duration\u003c/strong\u003e Routes that lasts less than this number of minutes will be discarded.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMinum Distance\u003c/strong\u003e Routes shorter than this number of meters will be discarded.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="inputs-and-outputs"\u003eInputs and outputs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eInput port\u003c/strong\u003e \u003cem\u003eInput data\u003c/em\u003e - The input table must contains at least the following columns:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eroute_id, a long identifying the route.\u003c/li\u003e\n\u003cli\u003evehicle_id, an integer identifying the vehicle id;\u003c/li\u003e\n\u003cli\u003etimestamp, a String identifying when this position was recorded;\u003c/li\u003e\n\u003cli\u003elocation, a WKT String containing positions (e.g.: \u0026ldquo;POINT( coordinate1 coordinate2)\u0026rdquo;.\nThe input data must be sorted by route_id.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eComputed routes\u003c/em\u003e - This port contains the routes computed according to the selected\nrouting strategy.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:3,href:"/docs/node-reference/map-matcher/map-matcher/",title:"Map Matcher",description:"The Map Matcher node matches each WKT-encoded input trajectory to a set of OpenStreetMap road segments.",content:'\u003c!-- \u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis documentation page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e --\u003e\r\n\u003ch2 id="node-description"\u003eNode description\u003c/h2\u003e\n\u003cp\u003eThis node takes a route, encoded as a WKT Linestring, and matches it to a sequence of traversed OSM road segments, that can be analyzed\nby the coverage analyzer nodes in KNOT.\u003c/p\u003e\n\u003ch2 id="configuration-options"\u003eConfiguration options\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCoordinate pair format\u003c/strong\u003e The setting informs the node about the type of coordinate pairs contained in\nthe Linestring. Either {lon,lat} or {lon,lat}.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOsm Data Path\u003c/strong\u003e The path in which the .osm file containing the map data can be found.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOsrm Host Field\u003c/strong\u003e The url at which the OSRM instance used for map-matching can be reached\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInclude Never Visited Segments\u003c/strong\u003e By enabling this checkbox also the segments that were never visited\nwill be added to the result table. If not, only the segments visited at least once will show up in the result.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="inputs-and-outputs"\u003eInputs and outputs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eInput port\u003c/strong\u003e \u003cem\u003eRoutes\u003c/em\u003e - A table containining data about routes.\nIt must contain at least the following columns:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ean integer that identifies the vehicle to which each trajectory belongs;\u003c/li\u003e\n\u003cli\u003ea LocalDateTime that pinpoints the starting time of the route;\u003c/li\u003e\n\u003cli\u003ea String containing a WKT-like representation of the route.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eMatched Segments\u003c/em\u003e - A table containing information about the traversed segments\nfor each input route and, optionally, data about the segments that were never visited.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:4,href:"/docs/node-reference/segment-coverage-analyzer/segment-coverage-analyzer/",title:"Segment Coverage Analyzer",description:"The Segment Coverage Analyzer node computes spatio-temporal coverage statistics for each road segment in the considered map.",content:'\u003c!-- \u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis documentation page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e --\u003e\r\n\u003ch2 id="node-description"\u003eNode description\u003c/h2\u003e\n\u003cp\u003eThe node takes as input a set of map matcher trajectories, possibly computed by the KNOT Map Matcher node.\nThe node computes as coverage metrics both the number of visits for each segment, and the average timegap between subsequent visits.\u003c/p\u003e\n\u003ch2 id="input-ports"\u003eInput ports\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eInput port\u003c/strong\u003e \u003cem\u003eMap-Matched Trajectories\u003c/em\u003e - The input table must have the following columns:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ean integer representing the vehicle id.\u003c/li\u003e\n\u003cli\u003ea LocalDateTime containing information on the moment at which the traversal of the road segment began.\u003c/li\u003e\n\u003cli\u003ea LocalDateTime containing information on the moment at which the traversal of the road segment ended.\u003c/li\u003e\n\u003cli\u003eorigin_id, the OSM id of the origin node of the road segment.\u003c/li\u003e\n\u003cli\u003edestination_id, the OSM id of the destination node of the road segment.\u003c/li\u003e\n\u003cli\u003etags, the OSM tags associated to the ways to which the origin and destination nodes both belong.\u003c/li\u003e\n\u003cli\u003ea geometry object representing the road segment, encoded as a WKT Linestring.\nThe output of the KNOT Map Matcher node can be directly fed to this input.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eRoad Segment Coverage Data by Day\u003c/em\u003e - A table containing coverage metrics computed for each day in the input dataset. The table contains the following information:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor each road segment, the origin and destination OSM nodes, their tags and a geometry representation as WKT Linestrings.\u003c/li\u003e\n\u003cli\u003eThe times it was traversed on a given day, the average time between visits and the same information\nbroken down among four time slots ([00:00-06:00],[06:00-12:00],[12:00-18:00],[18:00-24:00]).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eRoad Segment Coverage Data\u003c/em\u003e - A table containing the following information:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor each road segment, the origin and destination OSM nodes, their tags and a geometry representation as WKT Linestrings.\u003c/li\u003e\n\u003cli\u003eThe number of times it was traversed by the input trajectories and the average time between subsequent visits.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:5,href:"/docs/node-reference/grid-coverage-analyzer/grid-coverage-analyzer/",title:"Grid Coverage Analyzer",description:"The Grid Coverage Analyzer node computes spatio-temporal coverage statistics based on a customizable grid.",content:'\u003c!-- \u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis documentation page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e --\u003e\r\n\u003cshortDescription\u003e\r\n        Given a set of map-matched trajectories, splits a geographic area into a grid and computes how often each grid cell is visited.\r\n    \u003c/shortDescription\u003e\r\n\u003ch2 id="node-description"\u003eNode description\u003c/h2\u003e\n\u003cp\u003eThis node allows users to define a custom grid over a given geographical area by specifying a bounding box, a number of rows\nand a number of columns. It then proceeds to compute the number of times each grid cell was visited by one of the agents performing\nthe input map-matched trajectories. A visit to a grid cell is considered valid if the agent is entering that cell for the first time,\nor if the time between the current visit and the previous one is more than a threshold (in minutes), which can be customized\nin the input dialog.\nThe node offers two output tables, one considering the whole input data-set and the other grouping the coverage information\nby day.\u003c/p\u003e\n\u003ch2 id="configuration-options"\u003eConfiguration options\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMin Y\u003c/strong\u003e The minimum Latitude of the grid.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMax Y\u003c/strong\u003e The maximum Latitude of the grid.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMin X\u003c/strong\u003e The minimum Longitude of the grid.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMax X\u003c/strong\u003e The maximum Longitude of the grid.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNumber of rows\u003c/strong\u003e The number of rows of the grid.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNumber of columns\u003c/strong\u003e The number of columns of the grid.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMinimum time between visits\u003c/strong\u003e The minimum number of minutes for two subsequent visits by the same vehicle to be considered distinct.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="inputs-and-outputs"\u003eInputs and outputs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eInput port\u003c/strong\u003e \u003cem\u003eRoute Steps\u003c/em\u003e - The input data must contain the following information:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ean integer representing the vehicle id.\u003c/li\u003e\n\u003cli\u003ea LocalDateTime containing information on the moment at which the traversal of the road segment began.\u003c/li\u003e\n\u003cli\u003ea LocalDateTime containing information on the moment at which the traversal of the road segment ended.\u003c/li\u003e\n\u003cli\u003ea geometry object representing the road segment, encoded as a WKT Linestring\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eGrid Coverage Data By Day\u003c/em\u003e - Information on how often a grid cell was visited, broken down by day\nand by time slots within a day.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eGrid Coverage Data\u003c/em\u003e - Information on how often a grid cell was visited, aggregated over the entire timespan of the provided data.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:6,href:"/docs/node-reference/bounding-box-filter/bouding-box-geometry-filter/",title:"Bounding Box Filter",description:"Filters data based on whether a WKT geometry object is contained in customizable bounding box.",content:'\u003ch2 id="node-description"\u003eNode description\u003c/h2\u003e\n\u003cp\u003eThis node takes as input a table with a column containing geometry objects encoded in Well Know Text (WKT) format\nand the coordinates of a bounding box.\nThe node outputs a filtered version of the input table like, containing only entries for which the geometry\nis contained in the given bounding box.\u003c/p\u003e\n\u003ch2 id="configuration-options"\u003eConfiguration options\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGeometry Column\u003c/strong\u003e Column containing geometry objects encoded in WKT format.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCoordinate Input Format\u003c/strong\u003e Either {lon, lat} or {lat, lon}, accordingly to the input format.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMin Y\u003c/strong\u003e The minimum Latitude of the bounding box.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMax Y\u003c/strong\u003e The maximum Latitude of the bounding box.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMin X\u003c/strong\u003e The minimum Longitude of the bounding box.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMax X\u003c/strong\u003e The maximum Longitude of the bounding box.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="inputs-and-outputs"\u003eInputs and outputs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eInput port\u003c/strong\u003e \u003cem\u003eInput Data\u003c/em\u003e - Table to be filtered.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOutput port\u003c/strong\u003e \u003cem\u003eFiltered Data\u003c/em\u003e - This port contains the rows that fall within the bounding box area selected in the settings.\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:7,href:"/docs/prologue/introduction/",title:"Introduction",description:"KNOT is a KNIME plugin helping you visually compose intuitive, reproducible, and easy to distribute Knowledge Discovery pipelines for massive mobility datasets including â€” but not limited to â€” Floating Car Data (FCD) ones.",content:'\u003ch2 id="get-started"\u003eGet started\u003c/h2\u003e\n\u003cp\u003eThe simplest way to get started with KNOT is by following our\nstep-by-step example based on the real-world \u003ca href="/docs/usage-example/rome-example/"\u003eRome Taxi Mobility Dataset â†’\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eMore details on dependencies and installation procedure can be found in our \u003ca href="/docs/prologue/quick-start/"\u003eQuick Start â†’\u003c/a\u003e page.\u003c/p\u003e\n\u003ch2 id="go-further"\u003eGo further\u003c/h2\u003e\n\u003cp\u003eIf you want to learn more about KNOT, check out the\n\u003ca href="/docs/node-reference/"\u003eNode Reference â†’\u003c/a\u003e or the \u003ca href="https://github.com/luistar/knot"\u003eGitHub Repository â†’\u003c/a\u003e.\u003c/p\u003e\n'},{id:8,href:"/docs/prologue/quick-start/",title:"Quick Start",description:"One page summary of how to start using KNOT.",content:'\u003ch2 id="requirements"\u003eRequirements\u003c/h2\u003e\n\u003cp\u003eKNOT requires a KNIME installation, and has been tested on KNIME 4.5.2. The default implementations of the \u003ca href="/docs/node-reference/map-matcher/map-matcher/"\u003eMap Matcher\u003c/a\u003e and \u003ca href="/docs/node-reference/trajectory-manipulator/trajectory-manipulator/"\u003eTrajectory Manipulator\u003c/a\u003e nodes require also a running instance of the Open Source Routing Machine (OSRM). These nodes have been tested with OSRM 5.24.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDownload and install \u003ca href="https://knime.com/"\u003eKNIME\u003c/a\u003e for your platform.\u003c/li\u003e\n\u003cli\u003eDownload and install \u003ca href="http://project-osrm.org/"\u003eOSRM\u003c/a\u003e for your platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="install-knot"\u003eInstall KNOT\u003c/h2\u003e\n\u003cp\u003eAt the moment, the easiest way to install KNOT is to copy the most recent JAR\nfiles for the KNOT nodes (which you can download \u003ca href="https://github.com/todo/releases"\u003ehere\u003c/a\u003e)\nin the \u003ccode\u003edropins\u003c/code\u003e directory of your KNIME installation. On Windows systems, the path\nto the \u003ccode\u003edropins\u003c/code\u003e directory should look like this: \u003ccode\u003eC:\\Program Files\\KNIME\\dropins\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="start-knime"\u003eStart KNIME\u003c/h2\u003e\n\u003cp\u003eThat\u0026rsquo;s it! Next time you start KNIME, the KNOT nodes will be available in the node\nrepository.\u003c/p\u003e\n\u003ch2 id="run-osrm"\u003eRun OSRM\u003c/h2\u003e\n\u003cp\u003eIf you plan to use the default implementation of the \u003ca href="/docs/node-reference/trajectory-manipulator/trajectory-manipulator/"\u003eTrajectory Manipulator\u003c/a\u003e\nand/or the \u003ca href="/docs/node-reference/map-matcher/map-matcher/"\u003eMap Matcher\u003c/a\u003e node, you need an OSRM instance running and ready to serve\nrouting requests on the geographical area you intend to analyze.\u003c/p\u003e\n\u003ch3 id="download-relevant-openstreetmap-data"\u003eDownload relevant OpenStreetMap data\u003c/h3\u003e\n\u003cp\u003eA number of alternatives exist to download OpenStreetMap (OSM) data\n(\u003ca href="https://wiki.openstreetmap.org/wiki/Downloading_data"\u003echeck the wiki\u003c/a\u003e).\nThe most practical one is probably to use OSM extracts in PBF format provided by third parties\nsuch as \u003ca href="http://download.geofabrik.de/"\u003eGeoFabrik\u003c/a\u003e or \u003ca href="https://download.bbbike.org/osm/"\u003eBBBike.org\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eðŸ’¡\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eIf the available extracts are too large with respect to the area on which you want to carry-on your analyses, it might be a good idea performance-wise to further restrict the extracts by using tools like \u003ca href="https://wiki.openstreetmap.org/wiki/Osmconvert"\u003eOSMConvert\u003c/a\u003e.\u003c/div\u003e\r\n\u003c/div\u003e\n\u003ch3 id="prepare-osrm"\u003ePrepare OSRM\u003c/h3\u003e\n\u003cp\u003eBefore running OSRM, you need to extract a routing graph from the OSM data. To do so, run the\nfollowing commands.\u003c/p\u003e\n\u003cdiv class="doks-clipboard"\u003e\r\n  \u003cbutton class="btn-clipboard btn btn-link" data-clipboard-text="osrm-extract --profile /path/to/osmr/profiles/car.lua --with-osm-metadata yourdata.pbf "\u003e\u003cspan class="copy-status"\u003e\u003c/span\u003e\u003c/button\u003e\r\n\u003c/div\u003e\r\n\n\u003cpre\u003e\u003ccode class="language-bash"\u003eosrm-extract  --profile /path/to/osmr/profiles/car.lua \\\r\n              --with-osm-metadata yourdata.pbf \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above command creates \u003ccode\u003e.osmr\u003c/code\u003e named like the PBF you supplied as input.\nThen, issue the following:\u003c/p\u003e\n\u003cdiv class="doks-clipboard"\u003e\r\n  \u003cbutton class="btn-clipboard btn btn-link" data-clipboard-text="osrm-contract yourdata.osrm"\u003e\u003cspan class="copy-status"\u003e\u003c/span\u003e\u003c/button\u003e\r\n\u003c/div\u003e\r\n\n\u003cpre\u003e\u003ccode class="language-bash"\u003eosrm-contract yourdata.osrm \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="start-the-osrm-server"\u003eStart the OSRM server\u003c/h3\u003e\n\u003cp\u003eAfter this preprocessing step, you\u0026rsquo;re ready to start the OSRM router server by\nrunning the following command:\u003c/p\u003e\n\u003cdiv class="doks-clipboard"\u003e\r\n  \u003cbutton class="btn-clipboard btn btn-link" data-clipboard-text="osrm-routed --max-matching-size 3000 /path/to/osrm/data/yourdata.osrm"\u003e\u003cspan class="copy-status"\u003e\u003c/span\u003e\u003c/button\u003e\r\n\u003c/div\u003e\r\n\n\u003cpre\u003e\u003ccode class="language-bash"\u003eosrm-routed --max-matching-size 3000 /path/to/osrm/data/yourdata.osrm\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter that, you should see an output like the following and your OSRM instance should be up and running.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[info] starting up engines, v5.24.0\r\n[info] Threads: 4\r\n[info] IP address: 0.0.0.0\r\n[info] IP port: 5000\r\n[info] http 1.1 compression handled by zlib version 1.2.11\r\n[info] Listening on: 0.0.0.0:5000\r\n[info] running and waiting for requests\r\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:9,href:"/docs/help/how-to-update/",title:"How to Update",description:"",content:"\u003cp\u003eUpdating KNOT is easy! You can just replace the old JAR files in the \u003ccode\u003e/dropins/\u003c/code\u003e directory\nof your KNIME installation with the new ones.\u003c/p\u003e\n\u003cp\u003eAfter the deployment on the official KNIME Hub, which we hope will go live in a few days,\nupdating will be even easier!\u003c/p\u003e\n"},{id:10,href:"/docs/help/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:'\u003ch2 id="knime-needs-too-much-memory"\u003eKNIME needs too much memory\u003c/h2\u003e\n\u003cp\u003eAnalyzing massive datasets with KNOT can require more than 16 GB of RAM.\nIn the upcoming releases, we plan to adopt strategies to further optimize memory usage.\u003c/p\u003e\n\u003cp\u003eIn the meantime, running one single node at a time can help reduce memory usage.\nSplitting the original dataset in slices (e.g.: taking one week of\ndata at a time) and processing each slice separately can also help.\u003c/p\u003e\n\u003c!-- ## Problems updating npm packages\r\n\r\nDelete the `./node_modules` folder, and run again:\r\n\r\n```bash\r\nnpm install\r\n```\r\n\r\n## Problems with cache\r\n\r\nDelete the temporary directories:\r\n\r\n```bash\r\nnpm run clean\r\n``` --\u003e\r\n'},{id:11,href:"/docs/help/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:'\u003cdiv class="alert alert-warning d-flex" role="alert"\u003e\r\n  \u003cdiv class="flex-shrink-1 alert-icon"\u003eâš ï¸\u003c/div\u003e\r\n  \u003cdiv class="w-100"\u003eThis documentation page is currently under construction.\u003c/div\u003e\r\n\u003c/div\u003e\n\u003ch2 id="how-can-i-get-support"\u003eHow can I get support?\u003c/h2\u003e\n\u003cp\u003eCurrently, we have no FAQs. \u003ca href="https://luistar.github.io/"\u003eDrop us an email\u003c/a\u003e if you need support!\u003c/p\u003e\n\u003c!-- ## Hyas?\r\n\r\nDoks is a [Hyas theme](https://gethyas.com/themes/) build by the creator of Hyas.\r\n\r\n## Footer notice?\r\n\r\nPlease keep it in place.\r\n\r\n## Keyboard shortcuts for search?\r\n\r\n- focus: `/`\r\n- select: `â†“` and `â†‘`\r\n- open: `Enter`\r\n- close: `Esc`\r\n\r\n## Other documentation?\r\n\r\n- [Netlify](https://docs.netlify.com/)\r\n- [Hugo](https://gohugo.io/documentation/)\r\n\r\n## Can I get support?\r\n\r\nCreate a topic:\r\n\r\n- [Netlify Community](https://community.netlify.com/)\r\n- [Hugo Forums](https://discourse.gohugo.io/)\r\n- [Doks Discussions](https://github.com/h-enk/doks/discussions)\r\n\r\n## Contact the creator?\r\n\r\nSend `h-enk` a message:\r\n\r\n- [Netlify Community](https://community.netlify.com/)\r\n- [Hugo Forums](https://discourse.gohugo.io/)\r\n- [Doks Discussions](https://github.com/h-enk/doks/discussions) --\u003e\r\n'},{id:12,href:"/docs/help/",title:"Help",description:"Help Doks.",content:""},{id:13,href:"/docs/usage-example/",title:"Examples",description:"Usage Examples",content:""},{id:14,href:"/docs/node-reference/",title:"Node Reference",description:"Node Reference",content:""},{id:15,href:"/docs/prologue/",title:"Prologue",description:"Prologue Doks.",content:""},{id:16,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()